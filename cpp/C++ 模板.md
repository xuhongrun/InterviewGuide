# C++ 模板（Template）
C++ 模板（Template）是一种**泛型编程技术**，允许开发者编写可以在多种数据类型上工作的代码。模板可以将类型作为参数，使得代码可以在不同的数据类型上重用。
模板可以用于**函数**和**类**，使得同一份代码可以用于不同的数据类型。

### 函数模板

函数模板是一种可以操作多种数据类型的函数。
```cpp
template <typename T>
void myFunction(T param) {
    // 函数体，可以使用泛型类型T
}
```
`T`是一个占位符，表示任何类型。当你调用这个模板函数时，编译器会根据传入的参数类型自动实例化这个模板。
```cpp
myFunction(10);    // int类型实例化
myFunction(3.14);  // double类型实例化
myFunction("hello"); // const char*类型实例化
```
### 类模板

类模板允许你创建可以操作多种数据类型的类。
```cpp
template <typename T>
class myClass {
public:
    T value;

    void setValue(T val) {
        value = val;
    }

    T getValue() const {
        return value;
    }
};
```
`T`同样是一个类型参数。你可以这样使用类模板：
```cpp
myClass<int> intObj;
intObj.setValue(20);

myClass<double> doubleObj;
doubleObj.setValue(3.14);

std::cout << intObj.getValue() << std::endl; // 输出：20
std::cout << doubleObj.getValue() << std::endl; // 输出：3.14
```
### 模板特化
模板特化是为特定类型提供特定实现的一种方式。它可以覆盖模板的一般定义。
```cpp
template <typename T>
class myClass {
public:
    T value;
    // ...
};

// 特化为int类型
template <>
class myClass<int> {
public:
    int value;
    // 特化实现
};
```
### 模板偏特化
模板偏特化是为模板参数的特定部分提供特定实现的一种方式，它通常用于类模板。
```cpp
template <typename T, typename U>
class myPair {
public:
    T first;
    U second;
    // ...
};

// 偏特化为第一个类型为int的pair
template <typename U>
class myPair<int, U> {
public:
    int first;
    U second;
    // 偏特化实现
};
```
### 模板参数推断
C++11引入了模板参数推断，允许在某些情况下省略模板参数。
```cpp
template <typename T>
void myFunction(T param) {}

myFunction(10); // 编译器推断T为int
myFunction(3.14); // 编译器推断T为double
```
## 模板的工作原理
C++ 模板是通过**编译器**来实现的。编译器会将模板实例化为具体的代码，然后编译和链接这些代码。

### 模板实例化

当编译器遇到一个模板实例化时，它会将模板参数替换为实际的类型或值。例如：
```cpp
template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}

int a = 5;
int b = 10;
int max_val = max(a, b);
```
编译器会将模板参数 `T` 替换为 `int`，生成以下代码：
```cpp
int max(int a, int b) {
    return (a > b) ? a : b;
}

int a = 5;
int b = 10;
int max_val = max(a, b);
```

### 模板实例化的步骤
1. **模板参数替换**：编译器将模板参数替换为实际的类型或值。
2. **语法分析**：编译器对生成的代码进行语法分析。
3. **语义分析**：编译器对生成的代码进行语义分析。
4. **代码生成**：编译器生成机器代码。
5. **链接**：编译器将生成的机器代码链接到可执行文件中。

## C++ 可变参数模板（Variadic Templates）
C++11引入了可变参数模板（Variadic Templates），允许模板参数的数量可以变化。使得可以定义更灵活的模板函数和类。

#### 可变参数模板的基本语法
可变参数模板使用省略号 `...` 来表示参数包（parameter pack）。参数包可以是类型参数包，也可以是非类型参数包。

```cpp
template <typename... T> // 可变类型参数包
void func(T... args) { // 可变函数参数包
    // ...
}
```

#### 参数包展开
参数包可以通过递归或其他方式展开。一个常见的展开方式是使用递归函数模板：

```cpp
template <typename T>
void print(T value) {
    std::cout << value << std::endl;
}

template <typename First, typename... Rest>
void print(First first, Rest... rest) {
    std::cout << first << ", ";
    print(rest...); // 递归展开
}
```

#### 初始化列表展开
C++11还引入了初始化列表（initializer_list），可以用于展开参数包：

```cpp
template <typename... T>
void print(T... args) {
    std::initializer_list<int>{(std::cout << args << ", ", 0)...}; // 初始化列表展开
}
```

#### 可变参数模板的应用
可变参数模板可以用于实现类型安全的变参函数、元编程等。

##### 1. 类型安全的变参函数

```cpp
template <typename... T>
void safe_printf(const char* format, T... args) {
    // ...
}
```

##### 2. 元编程

```cpp
template <typename... Ts>
struct tuple {
    // ...
};
```

#### C++17的新特性

C++17引入了新的展开方式，包括：
- `std::apply`: 将参数包应用于函数。
- `std::make_tuple`等函数的变参版本。
- 折叠表达式（folding expressions）：允许使用简洁的语法展开参数包。

```cpp
template <typename... T>
auto sum(T... args) {
    return (args + ...); // 折叠表达式
}
```


## 模板优缺点
### 优点

- **类型安全**：模板允许在编译时检查类型，这有助于捕捉类型不匹配的错误，提高代码的安全性。
- **代码复用**：同一份模板代码可以用于不同的数据类型，这样可以避免为每种数据类型编写重复的代码。
- **性能**：模板在编译时实例化，这意味着没有运行时的类型检查开销，可以提供与非泛型代码相媲美的性能。
- **灵活性**：模板不仅可以用于简单的数据类型，还可以用于复杂的数据结构和算法，使得代码更加灵活。
- **编译时多态**：模板提供了一种编译时多态的方式，允许在编译时根据参数的不同生成不同的代码。
- **自动类型推导**：C++11及以后的版本支持自动类型推导，使得模板的使用更加方便。

### 缺点
- **编译时间**：模板代码在编译时实例化，这可能会导致编译时间增加，特别是当模板实例化很多或者模板定义很复杂时。
- **编译错误难以理解**：模板的编译错误通常难以理解，因为编译器需要展开模板代码，错误信息可能会非常长且复杂。
- **代码膨胀**：每个模板实例都会生成一份完整的代码副本，这可能会导致编译后的程序体积增大，尤其是在大型项目中。
- **模板元编程复杂性**：模板元编程（使用模板进行编译时计算）可以非常强大，但也可能导致代码难以理解和维护。
- **限制**：模板有一些限制，例如不能使用模板创建非常量大小的数组，也不能在模板中使用变长参数。
- **模板特化和偏特化可能导致问题**：模板特化和偏特化可以解决一些特定类型的问题，但过多使用会使代码复杂度增加，且可能导致链接错误（如二义性问题）。
- **依赖性问题**：模板代码的依赖性可能导致编译问题，尤其是当模板定义在不同的编译单元时。
- **调试困难**：调试模板代码可能比普通代码更困难，因为模板的实例化和展开可能会使得调试信息不那么直观。

## C++中泛型编程
泛型编程的目标是编写可以处理多种数据类型的代码，而不需要为每种类型编写专门的代码。在C++中，这主要通过**模板**来实现，但也可以通过**宏**来实现一些简单的泛型代码。
### C++ 模板
C++模板是泛型编程的核心特性，允许编写与数据类型无关的代码。模板可以用于函数和类。
- **类型安全**：模板提供了强类型检查，确保类型不匹配的错误在编译时被捕获。
- **编译时多态**：模板允许在编译时根据参数的不同生成不同的代码，这被称为编译时多态。
- **代码复用**：同一份模板代码可以用于不同的数据类型，减少了代码重复。
- **性能**：模板实例化后的代码与非泛型代码性能相当，因为所有的类型检查都在编译时完成。

### C++ 宏
宏是通过预处理器实现的，它们在代码编译之前进行文本替换。
- **类型无关**：宏不关心数据类型，它们只是简单地替换文本，因此不能提供类型安全。
- **预处理阶段**：宏在预处理阶段展开，这意味着它们不经过编译器的语义分析，因此不能访问类型信息。
- **代码膨胀**：宏可能会导致代码膨胀，因为它们在每个使用点都会展开，可能会产生重复的代码。
- **调试困难**：宏展开后的代码可能会使得调试变得困难，因为源代码和实际运行的代码之间存在差异。
### C++ 模板与宏
| **特性** | **模板 (Templates)** | **宏 (Macros)** |
| --- | --- | --- |
| 定义 | 编译器根据模板定义生成代码 | 预处理器根据宏定义替换代码 |
| 类型安全 | 保证类型安全 | 无类型安全检查 |
| 代码生成 | 编译器生成代码 | 预处理器替换代码 |
| 参数类型 | 可以有多个类型参数 | 只能有一个参数 |
| 参数值 | 参数值可以是任意表达式 | 参数值必须是常量 |
| 函数模板 | 可以定义函数模板 | 不支持函数宏 |
| 类模板 | 可以定义类模板 | 不支持类宏 |
| 特化 | 支持模板特化 | 不支持宏特化 |
| 重载 | 支持函数重载和运算符重载 | 不支持重载 |
| 编译期计算 | 支持编译期计算 | 不支持编译期计算 |
| 运行期计算 | 支持运行期计算 | 支持运行期计算 |
| 可读性 | 通常具有更好的可读性 | 可读性较差 |
| 维护性 | 更好的维护性 | 较差的维护性 |
| 使用场合 | 需要编写可重用、类型安全且性能高效的代码 | 需要在编译时执行简单的文本替换时 |
| 示例 | `template<typename T> struct Vector {};`<br>`template<int N> void function() {}` | `#define VECTOR_SIZE 10`<br>`#define FUNCTION(N) { ... }` |

> 模板是 C++ 中非常强大的特性，它允许编写**高度通用**且**类型安全**的代码。
> 相比之下，宏虽然简单并且可以用来实现某些特定目的，但由于缺乏类型安全性，在 C++ 编程中通常**建议尽量避免使用宏**，尤其是在模板可以解决问题的情况下。
