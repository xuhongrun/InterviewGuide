## 指针
指针全名为指针变量，它存储了另一个变量的内存地址。换言之，指针“指向”了内存中另一个变量的位置。
### 指针占用的大小
指针占用的大小取决于平台和编译器。一般来说，指针的大小为机器字长（word size），即：
1. 在 32 位系统中，指针的大小为 4 字节（32 位）。
2. 在 64 位系统中，指针的大小为 8 字节（64 位）。

> 常见平台和编译器的指针大小：
> - Windows 32 位：4 字节
> - Windows 64 位：8 字节
> - Linux 32 位：4 字节
> - Linux 64 位：8 字节
> - macOS 64 位：8 字节

在 C++ 中，可以使用 sizeof 运算符来获取指针的大小。例如：
```c++
int* p;
std::cout << "Pointer size: " << sizeof(p) << " bytes" << std::endl;
// 输出指针 p 的大小，以字节为单位
```
需要注意的是，指针的大小与它所指向的数据类型无关。无论指针指向的是 int、char还是其他类型，它的大小都是 **相同** 的。

> 此外，在 C++ 中，还有一些特殊的指针类型，它们的大小可能不同于普通指针。例如：
> - 函数指针：函数指针的大小可能比普通指针大，因为它需要存储函数的地址和调用约定。
> - 成员指针：成员指针的大小可能比普通指针大，因为它需要存储类的信息和成员函数的地址。
> - 虚拟指针：虚拟指针的大小可能比普通指针大，因为它需要存储虚拟函数表的地址。

**总之，指针的大小取决于平台和编译器，并且可能因指针类型而异。**
## 智能指针
智能指针是一种 C++ 类，它提供了动态分配对象的自动内存管理。它使得开发者可以使用指针，而不需要手动管理内存，从而避免了内存泄露和其他相关问题。
### 智能指针的本质
智能指针本质上是一个包装器，它将原始指针包装起来，并提供了额外的功能来管理对象的生命周期，包括：
1. **内存管理**：智能指针自动管理对象的内存，确保对象的正确分配和释放。
2. **引用计数**：智能指针维护对象的引用计数，以便在最后一个引用被删除时自动释放对象。
3. **安全**：智能指针提供了安全功能，例如防止空指针解引用和确保对象在被删除后不再被访问。
### 智能指针的实现原理
1. **RAII（资源获取即初始化）**：智能指针使用 RAII 来管理资源，例如内存。这意味着智能指针的构造函数获取资源，而析构函数释放资源。
2. **引用计数**：智能指针使用引用计数来维护对象的引用数。当引用计数达到零时，对象被释放。
3. **运算符重载**：智能指针重载运算符，例如 -> 和 *，以提供自然的指针接口。
### 智能指针的使用
#### C++ 标准库（STL）
头文件：`#include <memory>`
#### C++ 98
```cpp
std::auto_ptr<std::string> ps (new std::string(str))；
```
#### C++ 11
1. shared_ptr
2. unique_ptr
3. weak_ptr
4. ~~auto_ptr（C++11 弃用）~~

> Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。

> Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。

##### unique_ptr（唯一指针）

unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。

* unique_ptr 用于取代 auto_ptr

##### shared_ptr（共享指针）

多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。

* 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁

##### weak_ptr（弱指针）

weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。

* 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题

> weak_ptr真的不计数？是否有计数方式？在哪分配的空间？
>
> **计数**，控制块中有强弱引用计数，如果是使用make_shared初始化的函数则它所在的控制块空间是在所引用的shared_ptr中同一块的空间，若是new则控制器所分配的内存与shared_ptr本身所在的空间不在同一块内存。

##### ~~auto_ptr~~

~~被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 `std::move` 语义，以及其他瑕疵。~~

### unique_ptr、shared_ptr 比较
||unique_ptr | shared_ptr 
--- | --- | --- 
所有权 | 独占所有权 | 共享所有权
自动释放 | 是 | 是
可被复制 | 否 | 是
引用计数 | 否 | 是

> 在选择智能指针时，需要考虑以下几点：
> **对象的生命周期**：如果对象的生命周期是确定的，可以使用 unique_ptr。否则，使用 shared_ptr。
> **对象的共享**：如果多个指针需要共享同一个对象，使用 shared_ptr。否则，使用 unique_ptr。
> **性能**：如果需要高效的智能指针，可以使用 unique_ptr。否则，使用 shared_ptr。
> **安全性**：如果需要避免循环引用，可以使用 weak_ptr。
## 引用

引用（Reference）是一种复杂的类型，它是对变量的**别名**，是一个已命名的内存地址。

**引用可以看作是一个常量指针，但是它不能被修改，以指向其他变量。**
### 引用特点
1. 别名：引用是变量的别名，访问引用相当于访问原始变量。
2. 不可修改：引用不能被修改，以指向其他变量。
3. 必须初始化：引用必须在声明时初始化，否则编译器将报错。
### 引用类型
C++ 中有两种类型的引用：
#### 左值引用（Lvalue Reference）
 左值引用是对变量的别名，允许使用引用来访问和修改变量的值。
左值引用声明格式如下：
```cpp
类型 &引用名 = 变量名;
```
其中，类型 是变量的类型，引用名 是引用名称，变量名 是被引用的变量名称。
例如：
```cpp
int x = 10;
int &rx = x;  // 声明一个引用 rx，指向变量 x
```
- 别名：左值引用是变量的别名，我们可以使用引用来访问和修改变量的值。
- 左值：左值引用只能绑定到左值上，也就是说只能绑定到变量、数组元素、结构体成员等左值上。
- 不可修改：左值引用不能被修改，以指向其他变量。
##### 应用场景：
- 函数参数：左值引用可以作为函数参数，以避免复制对象。
- 返回值：左值引用可以作为函数返回值，以避免复制对象。
- 别名：左值引用可以作为变量的别名，以提高代码可读性。

#### 右值引用（Rvalue Reference）
右值引用是对临时对象的别名，允许使用引用来访问和修改临时对象的值。
右值引用的声明格式如下：
```cpp
类型 &&引用名 = 右值;
```
其中，类型 是临时对象的类型，引用名 是引用名称，右值 是临时对象的值。
例如：
```cpp
int &&rx = 10;  // 声明一个右值引用 rx，指向临时对象 10
```
- 临时对象：右值引用只能绑定到临时对象上，也就是说只能绑定到右值上。
- 不可修改：右值引用不能被修改，以指向其他临时对象。
- 生命周期：右值引用的生命周期与临时对象的生命周期相同，当临时对象被销毁时，右值引用也将失效。
##### 应用场景：
- 移动语义：右值引用可以用于实现移动语义，例如 std::move。
- 函数参数：右值引用可以作为函数参数，以避免复制对象。
- 返回值：右值引用可以作为函数返回值，以避免复制对象。
#### 引用应用场景
1. 函数参数：引用可以作为函数参数，以避免复制对象。
2. 返回值：引用可以作为函数返回值，以避免复制对象。
3. 别名：引用可以作为变量的别名，以提高代码可读性。
### 引用和指针的区别
| 特征 | 引用 | 指针
| --- | --- | ---
| 语法 | 类型 &引用名 = 变量名; | 类型 *指针名 = &变量名;
| 本质 | 变量的别名 | 存储内存地址的变量
| 占用内存单元 | 具有独立的空间地址 | 与被引用对象占同一个空间
| 初始化 | 必须在声明时初始化 | 可以在声明后初始化
| 重新赋值 | 不能重新赋值 | 可以重新赋值
| 空值 | 不能为空 | 可以为空（例如 nullptr）
| 操作符 | . | ->
| 生命周期 | 与被引用的变量相同 | 独立于被引用的变量
| 使用场景 | 函数参数、返回值、别名 | 动态内存分配、数组、链表
| 限制 | 不能用作数组索引，不能用作指针操作数 | 可以用作数组索引，可以用作指针操作数

## 特殊类型指针
#### this 指针
this 指针是一种特殊的指针，在 C++ 中用于引用当前对象的成员变量和成员函数。它是对象的隐式参数，当对象的成员函数被调用时，this 指针会自动传递给该函数。

1. 隐式参数：this 指针是对象的隐式参数，它会在对象的成员函数被调用时自动传递。
2. 指向当前对象：this 指针指向当前对象，即对象的成员函数被调用的对象。
3. 访问成员：this 指针用于访问对象的成员变量和成员函数。
4. 静态成员不需要：this 指针不需要用于静态成员，因为静态成员属于类本身，而不属于特定的对象。

用法有什么要注意的？

1. 使用this指针访问成员：使用 this 指针来访问对象的成员变量和成员函数，可以提高代码的可读性和维护性。
2. this指针是隐式的：在对象的成员函数中，this 指针是隐式的，不需要显式地声明或传递。
3. 避免使用this指针的歧义：在某些情况下，使用 this 指针可能会引起歧义，例如在嵌套函数中使用 this 指针。这种情况下，需要使用明确的对象名来访问成员。
4. this指针的生命周期：this 指针的生命周期与对象的生命周期相同，当对象被销毁时，this 指针也将失效。
### 野指针
野指针（Dangling Pointer）是一种特殊类型的指针，它指向已经被释放或已经不存在的内存地址。野指针可能会导致**程序崩溃、数据损坏或其他不可预测的行为**。
#### 野指针的出现原因
1. 指针变量没有被初始化。
2. 指针变量指向已经被释放的内存地址。
3. 指针变量指向已经不存在的对象。
#### 如何避免野指针
1. 初始化指针变量：在声明指针变量时，立即将其初始化为 NULL 或其他合法的值。
2. 使用智能指针：使用智能指针，如 unique_ptr、shared_ptr 等，它们可以自动管理内存，避免野指针的出现。
3. 检查指针的有效性：在使用指针之前，检查它是否为空或是否指向有效的内存地址。
4. 使用引用计数：使用引用计数机制，来跟踪指针的使用次数，当引用计数为零时，自动释放内存。
### 悬空指针
悬空指针（Void Pointer）是一种特殊类型的指针，它可以指向任何类型的对象，但不能直接访问对象的成员变量或成员函数。
悬空指针的定义是 void*，它可以指向任何类型的对象，包括基本类型、数组、结构体、类等。但是，悬空指针不能直接访问对象的成员变量或成员函数，因为编译器不知道指针所指向的对象的类型。
#### 悬空指针的优点是：
通用性：悬空指针可以指向任何类型的对象，使得它可以用于各种不同的场景。
灵活性：悬空指针可以被强制转换为其他类型的指针，使得它可以用于不同的编程任务。
#### 悬空指针的缺点是：
不安全性：悬空指针不能直接访问对象的成员变量或成员函数，使得它可能会导致程序崩溃或其他不可预测的行为。
低效率：悬空指针需要强制转换为其他类型的指针，使得它可能会导致性能下降。

#### 悬空指针的使用场景包括：
1. 泛型编程：悬空指针可以用于泛型编程，使得编程更加灵活和通用。
2. 底层编程：悬空指针可以用于底层编程，例如操作系统编程、嵌入式系统编程等。
3. 数据库编程：悬空指针可以用于数据库编程，例如存储过程编程、数据库驱动编程等。
### 常量指针
常量指针有两种
1. 指向常量的指针（Pointer to Constant）
```cpp
const int x = 10;
int * const p = &x;
```
p 是一个指针，它指向一个常量 x。这里的 const 修饰符意味着 p 指向的对象是常量，不能通过 p 修改 x 的值。
2. 常量指针（Constant Pointer）
```cpp
int x = 10;
int* const p = &x;
```
p 是一个常量指针，它指向一个变量 x。这里的 const 修饰符意味着 p 本身是常量，不能修改 p 的值，使得 p 永远指向 x。
> 在 C++ 中，const 修饰符的位置很重要。它可以修饰指针所指向的对象，也可以修饰指针本身。
### 函数指针（Function Pointer）
函数指针（Function Pointer）是一种特殊类型的指针，它指向一个函数，而不是一个变量。函数指针可以用来调用函数、传递函数作为参数、返回函数作为返回值等。
```cpp
返回值类型 (*指针名)(参数列表)
```
其中，返回值类型 是函数的返回值类型，指针名 是函数指针的名称，参数列表 是函数的参数列表。
```cpp
// 声明一个函数指针fp，指向一个返回值为 int、参数为两个 int 的函数
int (*fp)(int, int);
```
#### 赋值函数指针
```cpp
int add(int a, int b) { return a + b; }

int (*fp)(int, int) = add;  // 将函数 add 赋值给函数指针 fp
```
#### 使用函数指针调用函数
```cpp
int result = fp(2, 3);  // 通过函数指针 fp 调用函数 add，相当于调用 add(2, 3)
```
#### 函数指针的应用场景
1. 回调函数：在某些情况下，需要将一个函数作为参数传递给另一个函数，以便在特定的时刻调用该函数。函数指针可以实现这种需求。
2. 高阶函数：函数指针可以用来实现高阶函数，即将函数作为参数或返回值传递给其他函数。
3. 事件处理：在事件驱动编程中，函数指针可以用来注册事件处理函数，以便在事件发生时调用该函数。
> 需要注意的是，函数指针的使用需要遵守严格的类型检查，否则可能会导致程序崩溃或出现undefined behavior。
### 成员指针
成员指针（Member Pointer）是一种特殊的指针类型，它指向类的成员变量或成员函数。
#### 语法格式
成员指针的语法格式为：pointer-to-member，它由以下几部分组成：
**class-name::***：类名跟随一个星号，表示指向该类的成员。
**member-name**：成员变量或成员函数的名称

```cpp
// 定义一个类 Foo
class Foo {
public:
    int x;
    void bar() {}
};

// 定义一个成员指针 ptr，指向 Foo 的成员变量 x
int Foo::*ptr = &Foo::x;

// 定义一个成员指针 ptr，指向 Foo 的成员函数 bar
void (Foo::*ptr)() = &Foo::bar;

```
成员指针可以用来访问类的成员变量或成员函数，但是需要通过一个对象来间接访问。
例如：

```cpp
Foo obj;
int Foo::*ptr = &Foo::x;

obj.*ptr = 10;  // 等价于 obj.x = 10;
std::cout << obj.*ptr << std::endl;  // 输出 10

void (Foo::*ptr)() = &Foo::bar;
(obj.*ptr)();  // 等价于 obj.bar();

```
#### 成员指针的限制和注意事项
1. 成员指针只能指向**非静态**成员变量或成员函数。
2. 成员指针**不能指向虚拟成员函数**。
3. 成员指针需要通过一个对象来间接访问成员变量或成员函数。
### 指针指针
指针指针（Pointer to Pointer）是一种指针类型，它指向另一个指针。也就是说，一个指针指针是一个指针，它的值是另一个指针的地址。
#### 语法格式
指针指针的语法格式为：pointer-to-pointer，它由以下几部分组成：
**type****：类型名跟随两个星号，表示指向一个指针的指针。
**pointer-name**：指针指针的名称。

```cpp
// pp 是一个指针指针，它指向 p，而 p 是一个指针，指向 x
int x = 10;
int* p = &x;  // p 是一个指针，指向 x
int** pp = &p;  // pp 是一个指针指针，指向 p

```
#### 指针指针的注意事项
1. 指针指针需要非常小心地使用，以免出现**野指针**或**悬垂指针**。
2. 指针指针需要正确地初始化和释放内存，以免出现**内存泄露**。
3. 指针指针可以使代码变得复杂和难以理解，因此需要谨慎地使用。
